# 코딩테스트
## 알고리즘(Algorithm)이란
  + 알고리즘, 셈법은 수학과 컴퓨터과학, 언어학 또는 엮인 분야에서 어떠한 문제를 해결하기 위해 정해진 일련의 절차이다. 
  + 계산을 실행하기 위한 단계적 절차를 의미하기도 한다. 
  + 즉, 문제 풀이에 필요한 계산 절차 또는 처리 과정의 순서를 뜻한다. 
  + 프로그램명령어의 집합을 의미하기도 한다.
  + 입력 값과 출력 값을 매핑시켜주는 절차
## 효율성이란
  + 점근적 표기법: 알고리즘의 수행시간을 표기하기 위해, 필수적인 부분에 집중하 불필요한 상세들을 무시
  + 공간 복잡도: 메모리 차지
  + 시간 복잡도
    + 특정 크기의 입력에 대하여 알고리즘이 얼마나 오래 걸리는가?
    + 절대적인 시간을 측정하는 경우 Computer 성능에 따라 다를 수 있다.
    + 출력 값이 나올 때까지 연산의 횟수를 측정하는 것이 일반적이다.
    + 1억번의 연산은 대략 1초
    + 빅-오(Big-O): 최악의 경우
      + O(1) Constant
      + O(n) Linear
      + O(log(n)) Logarithmic
      + O(n*log(n)) Super linear
      + O(n^2) Quadratic, O(n^3) Cubic
      + O(n^k) Polynomial
      + O(k^n) Exponential, O(n!) Factorial
    + 빅-오메가(Big-Ω): 최상의 경우
    + 빅-세타(Big-θ): 빅-오(Big-O)와 빅-오메가(Big-Ω)의 교집합(두 범주 사이)
## Pseudo Code
  + 의사코드는 프로그램을 작성할 때 각 모듈이 작동하는 논리를 표현하기 위한 언어이다. 
  + 특정 프로그래밍 언어의 문법에 따라 쓰인 것이 아니라, 일반적인 언어로 코드를 흉내 내어 알고리즘을 써놓은 코드를 말한다.
  + 구체적인 코드를 생각하기 전에, How to do
## 코딩 테스트 알고리즘
+ 자료구조(Data Structure)
  + 배열과 리스트
  + 구간 합
    + 미리 계산 결과를 구해 둠 > 빠른 연산을 위한 중간 결과물 생성
    + 합 배열: S[i] = S[i-1] + A[i]
    + 구간 합: S[j] - S[i]
  + 투 포인터
    + 두 개의 포인터로 시간복잡도를 낮춤
    + 리스트를 선 정렬 > 포인터 위치 설정
    + 슬라이딩 윈도우
  + 스택과 큐
    + 스택(Stack)
      + LIFO, 재귀 함수 알고리즘 원리와 일맥상통
      + top: 삽입 삭제가 일어나는 위치
      + push: top 위치에 새로운 데이터 삽입
      + pop: top 위치의 데이터 삭제 및 확인
      + peek: top 위치의 데이터 단순 확인
      + DFS(Depth First Search, 깊이 우선 탐색), 백트래킹
    + 큐(Queue)
      + FIFO
      + rear: 큐의 마지막 데이터
      + front: 큐의 첫번째 데이터
      + add: 큐의 마지막(rear)에 새로운 데이터 삽입
      + poll: 큐의 처음(front)에 데이터를 삭제하고 확인
      + peek: 큐의 첫번째 데이터(front) 확인
      + BFS(Breadth First Search, 너비 우선 탐색)
      + 우선순위 큐(Priority Queue), 설정에 따라 우선 순위가 높은 데이터가 먼저 나옴, 힙(Heap)을 통해 구현하는 트리(Tree)의 한 종류
+ 정렬(Sorting)
  + 버블(Bubble)
    + 데이터의 인접 요소끼리 비교 하고 swap 연산
    + O(n^2) 느림
  + 선택(Selection)
    + 대상에서 가장 크거나 작은 데이터를 찾아가 선택을 반복
    + O(n^2) 느림
  + 삽입(Insertion)
    + 대상을 선택해 정렬된 영역에서 선택된 데이터의 적절한 위치를 찾아 삽입
    + O(n^2) 느림, 이진 트리를 활용해 적절한 삽입 위치를 찾는데 걸리는 시간을 O(n) -> O(logn) 까지 줄일 수 있음
  + 퀵(Quick)
    + pivot 값을 선정해 해당 값을 기준으로 정렬
    + 평균 O(nlogn) 최악 O(n^2)
  + 병합(Merge)
    + 이미 정렬된 부분 집합들을 효율적으로 병합
    + O(nlogn) 투 포인터(각 부분의 포인터)를 사용하여 병합
  + 기수(Radix)
    + 데이터의 자릿수를 바탕으로 비교, 값을 비교하지 않는 특이한 정렬
    + O(kn) k는 자릿수
    + 10개의 큐(버켓)를 이용, 각 큐는 자릿수를 대표
+ 탐색
  + 깊이우선탐색(DFS, Deep-First Search)
    + 그래프 완전 탐색 기법 중 하나
    + 그래프 시작 노드에서 출발하여 탐색할 한 쪽 분기를 정하여 최대 깊이까지 탐색을 마친 후 다른 쪽 분기로 이동하여 다시 탐색
    + 재귀 함수로 구현
    + 스택 자료구조 이용 - FILO
    + O(V + E) V: 노드 수, E: 엣지 수
    + 단절점 찾기, 단절선 찾기, 사이클 찾기, 위상 정렬 등
  + 너비우선탐색(BFS, Breadth-First Search)
    + 그래프 완전 탐색 기법 중 하나
    + 시작 노드에서 출발하여 시작노드를 기준으로 가까운 노드를 먼저 방문
    + 목표 노드에 도착하는 경로가 여러개 일 때, 최단 경로를 보장
    + 큐 자료구조 이용 - FIFO
    + O(V + E) V: 노드 수, E: 엣지 수
  + 이진(Binary Search)
+ 탐욕(Greedy)
+ 정수론
  + 소수 구하기
  + 오일러피
  + 유클리드 호제법
+ 그래프(Graph)
  + 유니온-파인드(Union-Find)
  + 위상 정렬(Topological Sort)
  + 다익스트라(Dijkstra)
  + 벨만-포드(Bellman-Ford)
  + 플로이드-위셜(Floyd-Warshall)
  + 최소 신장 트리(MST, Minimum Spanning Tree)
+ 트리(Tree)
  + 이진
  + 세그먼트
  + LCA(Lowest Common Ancestor)
+ 조합(Combination)
+ 동적 계획법(Dynamic Programming)
